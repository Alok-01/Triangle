Step-1 
Act:
Go to launchSettings.json file, which can be found in the Properties section of the Solution Explorer window.
LaunchBrowser property to 'false' to prevent the web browser from launching on application start.
Reason: 
Web API project and we don’t really need a browser to check our API out. 
We will use Postman (described later) for this purpose.

Knowledge-1
Before Core 3.0 Startup.cs using following stuffs:
a) UseKestrel() b) the UseIISIntegration()

Step-2
In Configure Method of Startup.cs, add following
app.UseForwardedHeaders() will forward proxy headers to the current request. This will help us during application deployment. 
app.UseStaticFiles() enables using static files for the request. If we don’t set a path to the static files directory, it will use a wwwroot folder in our project by default.

Knowledge-2
a) So the UseRouting() method should be called before the UseAuthorization() method and UseCors() or UseStaticFiles() 
   have to be called before the UseRouting() method.
b) instead of AddMvc() as used in 2.2, now we have AddControllers(). This method registers only the controllers in IServiceCollection 
   and not Views or Pages because they are not required in the Web API project which we are building.

Knowledge-3
a) services.AddSingleton: 
   By calling the services.AddSingleton method, we can create a service the first time we request it and then every subsequent request will call the 
   same instance of the service. This means that all components share the same service every time they need it and the same instance will be used for 
   every method call. 
  
b) services.AddScoped:
   By calling the services.AddScoped method, we can create a service once per request.
   That means whenever we send an HTTP request to the application, a new instance of the service will be created. 

c) services.AddTransient:   
   By calling the services.AddTransient method, we can create a service each time the application requests it. This means that if multiple components need 
   the service, it will be created again for every single component request.

Knowledge-4
What is Dependency Injection (DI) exactly and what is IoC (Inversion of Control)?
Dependency injection is a technique we use to achieve the decoupling of objects and their dependencies. 
It means that rather than instantiating an object explicitly in a class every time we need it, we can instantiate it once and then send it to the class.
This is often done through a constructor. The specific approach we utilize is also known as the Constructor Injection.
In a system that is designed around DI, you may find many classes requesting their dependencies via their constructors. 
In this case, it is helpful to have a class that manages and provides dependencies to classes through the constructor.
These classes are referred to as containers or more specifically, Inversion of Control containers. 
An IoC container is essentially a factory that is responsible for providing instances of the types that are requested from it.

Knowledge-5
1) HTTPPUT : Additional note: As you can see, we have changed only the Age property, but we have sent all the other properties 
with unchanged values as well. Therefore, Age is only updated in the database. But if we send the object with just the Age property, 
without the other properties, those other properties will be set to their default values and the whole object will be updated — not just the Age column. 
That’s because the PUT is a request for a full update. This is very important to know.
2) HTTPPATCH : The partial update isn’t the only difference between PATCH and PUT. The request body is different as well. 
For the Company PATCH request, for example, we should use [FromBody]JsonPatchDocument<Company> and not [FromBody]Company  as we did with the PUT requests.
Additionally, for the PUT request’s media type, we have used application/json — but for the PATCH request’s media type,
we should use application/json-patch+json. Even though the first one would be accepted in ASP.NET Core for the PATCH request, the recommendation 
by REST standards is to use the second one.
the PATCH request body looks like:
[ 
    { 
    "op": "replace", 
    "path": "/name", 
    "value": "new name" 
    }, 
    { 
    "op": "remove", 
    "path": "/name" 
    } 
]
The square brackets represent an array of operations. Every operation is placed between curly brackets. So, in this specific example, 
we have two operations: Replace and Remove represented by the op property. The path property represents the object’s property that
we want to modify and the value property represents a new value.

The Microsoft.AspNetCore.JsonPatch library to support the usage of JsonPatchDocument in our controller and
The Microsoft.AspNetCore.Mvc.NewtonsoftJson library to support request body conversion to a PatchDocument once we send our request.

Once the installation is completed, we have to add the NewtonsoftJson configuration to IServiceCollection:
services.AddControllers(config => 
{ 
config.RespectBrowserAcceptHeader = true; 
config.ReturnHttpNotAcceptable = true; 
config.OutputFormatters.Add(new CsvOutputFormatter()); 
})
.AddNewtonsoftJson() //// ******Add this*****
.AddXmlDataContractSerializerFormatters() 
.AddCustomCSVFormatter();

3) Example of Patch
https://localhost:5001/api/companies/3d490a70-94ce-4d15-9494-5248280c2ce3

--For Patch

--https://localhost:5001/api/companies/C9D4C053-49B6-410C-BC78-2D54A9991870/employees/80ABBCA8-664D-4B20-B5DE-024705497D4A
--Replace
--[
--	{
--"op": "replace",
--"path" : "/age",
--"value": "45"
--	}
--]

--Remove
--[
--	{
--"op": "remove",
--"path" : "/age"
--	}
--]

-- Add
--[
--	{
--"op": "add",
--"path" : "/age",
--"value" : 75
--	}
--]